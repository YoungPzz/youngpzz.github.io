---
title: 【Android】RecyclerView中的适配器模式
date: 2025-12-01 10:20:00 +0800
categories: [Android, 设计模式]
tags: [Android]     # TAG names should always be lowercase
description: 设计模式

---
 
# 适配器模式全解析：从理论本质到RecyclerView实战

在面向对象设计中，适配器模式是解决“接口不兼容”问题的经典方案，它如同现实世界中的“转换插头”，让原本无法协作的组件实现无缝对接。而在Android开发领域，RecyclerView的适配器（RecyclerView.Adapter）则是该模式的进阶实践——它不仅延续了“接口适配”的核心思想，更融合了数据绑定、视图复用等实战需求，成为连接数据源与视图容器的关键枢纽。本文将从纯适配器模式的理论出发，逐步延伸至RecyclerView适配器的实现细节，厘清两者的内在关联与独特价值。

# 一、纯适配器模式：接口兼容的“翻译官”

纯适配器模式是GOF23种设计模式中“结构型模式”的代表，其核心目标是在不修改原有组件代码的前提下，解决两个接口不兼容的问题，实现组件间的协同工作。它通过引入一个中间适配层，完成接口的转换与功能的转发，完美践行“开闭原则”与“单一职责原则”。

## 1.1 核心结构：三大角色的明确分工

任何适配器模式的实现都离不开三个核心角色，它们共同构成“客户端→适配器→被适配者”的协作链路，这是理解该模式的基础框架：

- **目标（Target）**：客户端（调用方）期望的接口规范，定义了客户端需要的功能方法。它是适配器必须实现的“标准”，确保客户端能以统一的方式调用功能。例如，系统需要一个“数据格式化”接口，包含formatData()方法，这就是目标接口。

- **被适配者（Adaptee）**：功能完整但接口与目标不兼容的现有组件，可以是第三方库、遗留代码或自定义类。它具备客户端需要的核心能力，只是调用方式不符合目标接口规范。比如已有一个“数据处理”类，包含processData()方法，能完成数据处理但方法名与目标接口不一致，便是被适配者。

- **适配器（Adapter）**：模式的核心枢纽，它同时具备两个特征——一是实现目标接口，满足客户端的调用规范；二是持有被适配者的引用，能调用其核心功能。适配器通过内部逻辑将被适配者的方法“翻译”为目标接口的方法，实现两者的兼容。例如，适配器实现“数据格式化”接口，在formatData()方法内部调用被适配者的processData()方法，并对返回结果进行格式转换。

## 1.2 实现方式：类适配器与对象适配器

根据适配器与被适配者的关联方式，纯适配器模式分为两种常见实现，各有适用场景：

### 1. 类适配器（继承实现）

适配器通过继承被适配者类，并实现目标接口，完成接口转换。这种方式的优点是能直接复用被适配者的方法，缺点是受限于单继承机制，灵活性较低。

```java

// 目标接口（客户端期望的标准）
public interface DataFormatter {
    String formatData(String rawData);
}

// 被适配者（接口不兼容但功能完整）
public class DataProcessor {
    // 核心功能：处理数据但返回格式不符合目标接口
    public String processData(String data) {
        return "Processed: " + data;
    }
}

// 类适配器（继承被适配者+实现目标接口）
public class ClassAdapter extends DataProcessor implements DataFormatter {
    @Override
    public String formatData(String rawData) {
        // 调用被适配者的核心方法，完成接口转换
        String processedData = super.processData(rawData);
        // 额外处理：满足目标接口的格式要求
        return "Formatted: " + processedData;
    }
}

// 客户端调用（只依赖目标接口）
public class Client {
    public static void main(String[] args) {
        DataFormatter formatter = new ClassAdapter();
        System.out.println(formatter.formatData("test")); 
        // 输出：Formatted: Processed: test
    }
}
```

### 2. 对象适配器（组合实现）

适配器通过组合方式持有被适配者的引用，而非继承，同时实现目标接口。这种方式规避了单继承限制，能适配多个被适配者，是更常用的实现方式，符合“合成复用原则”。

```java

// 目标接口与被适配者同上（DataFormatter、DataProcessor）

// 对象适配器（组合被适配者+实现目标接口）
public class ObjectAdapter implements DataFormatter {
    // 持有被适配者的引用
    private DataProcessor dataProcessor;

    // 构造函数注入被适配者（解耦，便于替换）
    public ObjectAdapter(DataProcessor dataProcessor) {
        this.dataProcessor = dataProcessor;
    }

    @Override
    public String formatData(String rawData) {
        // 调用被适配者的核心方法
        String processedData = dataProcessor.processData(rawData);
        // 接口转换逻辑
        return "Formatted: " + processedData;
    }
}

// 客户端调用
public class Client {
    public static void main(String[] args) {
        DataProcessor processor = new DataProcessor();
        DataFormatter formatter = new ObjectAdapter(processor);
        System.out.println(formatter.formatData("test"));
        // 输出：Formatted: Processed: test
    }
}
```

## 1.3 核心价值与经典场景

纯适配器模式的价值体现在“解耦”与“复用”两大维度：

1. **解耦不兼容组件**：客户端仅依赖目标接口，无需关注被适配者的具体实现，被适配者的修改不会直接影响客户端，降低代码耦合度。

2. **复用现有功能**：无需重写被适配者的核心逻辑，通过适配器即可将其整合到新系统中，避免代码冗余。

3. **灵活扩展**：新增被适配者时，只需新增对应的适配器，无需修改原有代码，提升系统可扩展性。

其经典应用场景包括：集成第三方库（接口与系统不匹配）、重构遗留代码（保留旧功能但适配新接口）、跨模块协作（模块间接口规范不一致）等。正如《Effective Java》条目6所强调，纯适配器通常是“无状态”的——自身不存储核心数据，仅依赖被适配者完成功能，因此可安全复用，例如Java集合的Collections.unmodifiableList()返回的适配器，即可反复用于限制列表修改。

# 二、RecyclerView适配器：适配器模式的Android实战进化

Android中的RecyclerView是高效展示大量列表数据的核心组件，其内置的RecyclerView.Adapter（简称“RecyclerView适配器”）是适配器模式的典型落地，但并非简单的接口转换。它结合Android视图渲染的特殊需求，扩展出数据绑定、视图复用等职责，成为“数据源→视图容器”的全能桥梁，解决了“原始数据无法直接渲染”的核心问题。

## 2.1 角色映射：适配器模式的Android化落地

RecyclerView适配器完全契合适配器模式的三大角色，只是结合Android场景进行了具体映射，明确了各方的职责边界：

| 适配器模式角色      | RecyclerView中的对应实现                         | 核心职责                                                   |
| ------------------- | ------------------------------------------------ | ---------------------------------------------------------- |
| 目标（Target）      | RecyclerView.Adapter抽象类                       | 定义RecyclerView的调用规范，如创建视图、绑定数据等抽象方法 |
| 被适配者（Adaptee） | 开发者定义的数据源（如List<User>、数据库结果集） | 存储原始数据，无视图关联能力，无法直接被RecyclerView渲染   |
| 适配器（Adapter）   | 自定义Adapter子类（如UserAdapter）               | 持有数据源引用，实现目标接口，完成数据→视图的转换与绑定    |
## 2.2 核心职责：从接口转换到全能管理

与纯适配器模式仅关注“接口转换”不同，RecyclerView适配器是“接口转换器+数据绑定器+视图复用管理器”的结合体，三大职责共同保障列表的高效渲染：

### 1. 接口适配：数据操作与视图指令的转换

RecyclerView无法直接识别数据源的增删改查操作，适配器需要承担“翻译”工作：将“数据变化”转换为RecyclerView能理解的“视图更新指令”。例如，数据源新增数据时，适配器通过notifyItemInserted()方法告知RecyclerView“在指定位置插入Item”；数据删除时，通过notifyItemRemoved()触发视图移除。同时，适配器通过getItemCount()方法将数据源大小转换为RecyclerView需要的“Item总数”，完成基础接口适配。

### 2. 数据绑定：原始数据到视图的可视化转换

数据源中的原始数据（如User对象的name、age属性）无法直接展示在TextView等控件上，适配器的核心工作就是完成“数据格式→视图内容”的转换。在onBindViewHolder()方法中，适配器从数据源获取指定位置的原始数据，将其绑定到ViewHolder的控件上——例如将User的name属性设置为TextView的文本，将int类型的age转换为字符串后展示，最终实现数据的可视化。

### 3. 视图复用：性能优化的核心保障

列表滚动时频繁创建/销毁Item视图会严重消耗性能，RecyclerView的核心优化点是“视图复用”，而适配器是这一机制的执行者：

- 通过onCreateViewHolder()创建视图容器（ViewHolder），持有Item布局中的控件引用，避免重复调用findViewById()；

- 当Item滑出屏幕时，RecyclerView将ViewHolder回收至缓存池；

- 新Item滑入屏幕时，适配器从缓存池获取复用的ViewHolder，在onBindViewHolder()中为其重新绑定新位置的数据，实现“视图复用、数据更新”的高效逻辑。

## 2.3 代码解析：RecyclerView适配器的实现逻辑

以下通过“用户列表”示例，拆解RecyclerView适配器的核心代码，直观理解其如何落地适配器模式：

### 1. 被适配者：原始数据源

纯数据对象及集合，无任何视图关联逻辑，是典型的被适配者：

```java

// 数据模型（纯数据，无视图逻辑）
public class User {
    private String name;
    private int age;

    // 构造函数、getter/setter省略
}

// 数据源（被适配者）
List<User> userList = new ArrayList<>();
userList.add(new User("张三", 20));
userList.add(new User("李四", 22));
```

### 2. 目标接口：RecyclerView.Adapter抽象类

Android框架定义的目标接口，规范了适配器的核心方法：

```java

public abstract class RecyclerView.Adapter<VH extends RecyclerView.ViewHolder> {
    // 创建ViewHolder（视图容器）
    public abstract VH onCreateViewHolder(ViewGroup parent, int viewType);
    // 绑定数据到视图
    public abstract void onBindViewHolder(VH holder, int position);
    // 返回Item总数
    public abstract int getItemCount();
}
```

### 3. 适配器：自定义UserAdapter

实现目标接口，持有数据源引用，完成适配逻辑：

```java

// 自定义适配器（实现目标接口+持有被适配者引用）
public class UserAdapter extends RecyclerView.Adapter<UserAdapter.UserViewHolder> {
    // 持有被适配者（数据源）
    private List<User> mUserList;

    // 构造函数注入数据源（解耦，符合依赖注入思想）
    public UserAdapter(List<User> userList) {
        this.mUserList = userList;
    }

    // 1. 创建视图容器：加载Item布局，初始化控件
    @Override
    public UserViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {
        View itemView = LayoutInflater.from(parent.getContext())
                .inflate(R.layout.item_user, parent, false);
        return new UserViewHolder(itemView);
    }

    // 2. 数据绑定：将被适配者数据转换为视图内容（适配核心）
    @Override
    public void onBindViewHolder(UserViewHolder holder, int position) {
        // 获取原始数据
        User currentUser = mUserList.get(position);
        // 数据→视图转换
        holder.tvName.setText(currentUser.getName());
        holder.tvAge.setText(String.valueOf(currentUser.getAge()));
    }

    // 3. 接口适配：返回Item总数
    @Override
    public int getItemCount() {
        return mUserList == null ? 0 : mUserList.size();
    }

    // 视图容器：持有Item控件，实现视图复用
    public static class UserViewHolder extends RecyclerView.ViewHolder {
        TextView tvName;
        TextView tvAge;

        public UserViewHolder(View itemView) {
            super(itemView);
            tvName = itemView.findViewById(R.id.tv_name);
            tvAge = itemView.findViewById(R.id.tv_age);
        }
    }

    // 数据更新的接口适配
    public void addUser(User user) {
        mUserList.add(user);
        notifyItemInserted(mUserList.size() - 1); // 数据添加→视图插入
    }
}
```

### 4. 客户端调用：连接RecyclerView与适配器

RecyclerView作为客户端，通过适配器调用被适配者的功能：

```java

public class MainActivity extends AppCompatActivity {
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        // 初始化RecyclerView（客户端）
        RecyclerView recyclerView = findViewById(R.id.recycler_view);
        recyclerView.setLayoutManager(new LinearLayoutManager(this));

        // 初始化适配器（连接客户端与被适配者）
        UserAdapter adapter = new UserAdapter(userList);

        // 客户端绑定适配器，完成协作
        recyclerView.setAdapter(adapter);

        // 数据更新：通过适配器触发视图更新
        adapter.addUser(new User("王五", 25));
    }
}
```

# 三、纯适配器模式与RecyclerView适配器的核心差异

尽管RecyclerView适配器基于纯适配器模式，但结合Android实战需求，两者存在显著差异，具体体现在以下维度：

| 对比维度 | 纯适配器模式                       | RecyclerView适配器                                             |
| -------- | ---------------------------------- | -------------------------------------------------------------- |
| 核心职责 | 仅完成接口转换，实现组件兼容       | 接口转换+数据绑定+视图复用+性能优化                            |
| 状态特性 | 通常无状态，可复用同一个适配器实例 | 有状态（持有数据源），一个适配器对应一个RecyclerView，不可复用 |
| 被适配者 | 有核心功能但接口不兼容的组件       | 无视图能力的纯数据源（如List）                                 |
| 设计目标 | 解耦与复用组件                     | 高效实现数据可视化与列表性能优化                               |
# 四、总结：适配器模式的本质与实践启示

适配器模式的核心本质是“中间层转换”——纯模式中是“接口转换”，解决组件兼容问题；RecyclerView适配器中是“数据→视图的全链路转换”，解决列表渲染问题。两者虽职责范围不同，但都遵循“不修改原有组件、通过适配层实现协作”的核心思想。

对于开发者而言，理解这种联系与差异具有重要实践意义：在Android开发中，编写RecyclerView适配器时，需牢牢把握“数据绑定”与“视图复用”两大核心，同时理解其适配器模式的本质，合理设计数据源与视图的适配逻辑；在其他场景遇到接口不兼容问题时，可回归纯适配器模式的设计思想，通过类适配或对象适配实现组件的灵活整合，最终构建高可维护、高可扩展的代码体系。
